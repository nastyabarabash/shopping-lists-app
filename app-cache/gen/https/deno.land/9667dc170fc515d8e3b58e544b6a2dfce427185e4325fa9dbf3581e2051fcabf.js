import { Connection } from "./connection/connection.ts";
import { createParams } from "./connection/connection_params.ts";
import { Query, ResultType, templateStringToQuery } from "./query/query.ts";
import { Transaction } from "./query/transaction.ts";
import { isTemplateString } from "./utils/utils.ts";
export class QueryClient {
  #connection;
  #terminated = false;
  #transaction = null;
  constructor(connection){
    this.#connection = connection;
  }
  get connected() {
    return this.#connection.connected;
  }
  get session() {
    return {
      current_transaction: this.#transaction,
      pid: this.#connection.pid,
      tls: this.#connection.tls,
      transport: this.#connection.transport
    };
  }
  #assertOpenConnection() {
    if (this.#terminated) {
      throw new Error("Connection to the database has been terminated");
    }
  }
  async closeConnection() {
    if (this.connected) {
      await this.#connection.end();
    }
    this.resetSessionMetadata();
  }
  /**
   * Transactions are a powerful feature that guarantees safe operations by allowing you to control
   * the outcome of a series of statements and undo, reset, and step back said operations to
   * your liking
   *
   * In order to create a transaction, use the `createTransaction` method in your client as follows:
   *
   * ```ts
   * import { Client } from "./client.ts";
   *
   * const client = new Client();
   * const transaction = client.createTransaction("my_transaction_name");
   *
   * await transaction.begin();
   * // All statements between begin and commit will happen inside the transaction
   * await transaction.commit(); // All changes are saved
   * ```
   *
   * All statements that fail in query execution will cause the current transaction to abort and release
   * the client without applying any of the changes that took place inside it
   *
   * ```ts
   * import { Client } from "./client.ts";
   *
   * const client = new Client();
   * const transaction = client.createTransaction("transaction");
   *
   * await transaction.begin();
   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
   * try {
   *   await transaction.queryArray`SELECT []`; // Invalid syntax, transaction aborted, changes won't be applied
   * }catch(e){
   *   await transaction.commit(); // Will throw, current transaction has already finished
   * }
   * ```
   *
   * This however, only happens if the error is of execution in nature, validation errors won't abort
   * the transaction
   *
   * ```ts
   * import { Client } from "./client.ts";
   *
   * const client = new Client();
   * const transaction = client.createTransaction("transaction");
   *
   * await transaction.begin();
   * await transaction.queryArray`INSERT INTO MY_TABLE (X) VALUES ${"some_value"}`;
   * try {
   *   await transaction.rollback("unexistent_savepoint"); // Validation error
   * } catch(e) {
   *   await transaction.commit(); // Transaction will end, changes will be saved
   * }
   * ```
   *
   * A transaction has many options to ensure modifications made to the database are safe and
   * have the expected outcome, which is a hard thing to accomplish in a database with many concurrent users,
   * and it does so by allowing you to set local levels of isolation to the transaction you are about to begin
   *
   * Each transaction can execute with the following levels of isolation:
   *
   * - Read committed: This is the normal behavior of a transaction. External changes to the database
   *   will be visible inside the transaction once they are committed.
   *
   * - Repeatable read: This isolates the transaction in a way that any external changes to the data we are reading
   *   won't be visible inside the transaction until it has finished
   *   ```ts
   *   import { Client } from "./client.ts";
   *
   *   const client = new Client();
   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "repeatable_read" });
   *   ```
   *
   * - Serializable: This isolation level prevents the current transaction from making persistent changes
   *   if the data they were reading at the beginning of the transaction has been modified (recommended)
   *   ```ts
   *   import { Client } from "./client.ts";
   *
   *   const client = new Client();
   *   const transaction = await client.createTransaction("my_transaction", { isolation_level: "serializable" });
   *   ```
   *
   * Additionally, each transaction allows you to set two levels of access to the data:
   *
   * - Read write: This is the default mode, it allows you to execute all commands you have access to normally
   *
   * - Read only: Disables all commands that can make changes to the database. Main use for the read only mode
   *   is to in conjuction with the repeatable read isolation, ensuring the data you are reading does not change
   *   during the transaction, specially useful for data extraction
   *   ```ts
   *   import { Client } from "./client.ts";
   *
   *   const client = new Client();
   *   const transaction = await client.createTransaction("my_transaction", { read_only: true });
   *   ```
   *
   * Last but not least, transactions allow you to share starting point snapshots between them.
   * For example, if you initialized a repeatable read transaction before a particularly sensible change
   * in the database, and you would like to start several transactions with that same before the change state
   * you can do the following:
   *
   * ```ts
   * import { Client } from "./client.ts";
   *
   * const client_1 = new Client();
   * const client_2 = new Client();
   * const transaction_1 = client_1.createTransaction("transaction_1");
   *
   * const snapshot = await transaction_1.getSnapshot();
   * const transaction_2 = client_2.createTransaction("new_transaction", { isolation_level: "repeatable_read", snapshot });
   * // transaction_2 now shares the same starting state that transaction_1 had
   * ```
   *
   * https://www.postgresql.org/docs/14/tutorial-transactions.html
   * https://www.postgresql.org/docs/14/sql-set-transaction.html
   */ createTransaction(name, options) {
    this.#assertOpenConnection();
    return new Transaction(name, options, this, // Bind context so function can be passed as is
    this.#executeQuery.bind(this), (name)=>{
      this.#transaction = name;
    });
  }
  /**
   * Every client must initialize their connection previously to the
   * execution of any statement
   */ async connect() {
    if (!this.connected) {
      await this.#connection.startup(false);
      this.#terminated = false;
    }
  }
  /**
   * Closing your PostgreSQL connection will delete all non-persistent data
   * that may have been created in the course of the session and will require
   * you to reconnect in order to execute further queries
   */ async end() {
    await this.closeConnection();
    this.#terminated = true;
  }
  async #executeQuery(query) {
    return await this.#connection.query(query);
  }
  async queryArray(query_template_or_config, ...args) {
    this.#assertOpenConnection();
    if (this.#transaction !== null) {
      throw new Error(`This connection is currently locked by the "${this.#transaction}" transaction`);
    }
    let query;
    if (typeof query_template_or_config === "string") {
      query = new Query(query_template_or_config, ResultType.ARRAY, args[0]);
    } else if (isTemplateString(query_template_or_config)) {
      query = templateStringToQuery(query_template_or_config, args, ResultType.ARRAY);
    } else {
      query = new Query(query_template_or_config, ResultType.ARRAY);
    }
    return await this.#executeQuery(query);
  }
  async queryObject(query_template_or_config, ...args) {
    this.#assertOpenConnection();
    if (this.#transaction !== null) {
      throw new Error(`This connection is currently locked by the "${this.#transaction}" transaction`);
    }
    let query;
    if (typeof query_template_or_config === "string") {
      query = new Query(query_template_or_config, ResultType.OBJECT, args[0]);
    } else if (isTemplateString(query_template_or_config)) {
      query = templateStringToQuery(query_template_or_config, args, ResultType.OBJECT);
    } else {
      query = new Query(query_template_or_config, ResultType.OBJECT);
    }
    return await this.#executeQuery(query);
  }
  resetSessionMetadata() {
    this.#transaction = null;
  }
}
/**
 * Clients allow you to communicate with your PostgreSQL database and execute SQL
 * statements asynchronously
 *
 * ```ts
 * import { Client } from "./client.ts";
 *
 * const client = new Client();
 * await client.connect();
 * await client.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
 * await client.end();
 * ```
 *
 * A client will execute all their queries in a sequential fashion,
 * for concurrency capabilities check out connection pools
 *
 * ```ts
 * import { Client } from "./client.ts";
 *
 * const client_1 = new Client();
 * await client_1.connect();
 * // Even if operations are not awaited, they will be executed in the order they were
 * // scheduled
 * client_1.queryArray`UPDATE MY_TABLE SET MY_FIELD = 0`;
 * client_1.queryArray`DELETE FROM MY_TABLE`;
 *
 * const client_2 = new Client();
 * await client_2.connect();
 * // `client_2` will execute it's queries in parallel to `client_1`
 * const {rows: result} = await client_2.queryArray`SELECT * FROM MY_TABLE`;
 *
 * await client_1.end();
 * await client_2.end();
 * ```
 */ export class Client extends QueryClient {
  constructor(config){
    super(new Connection(createParams(config), async ()=>{
      await this.closeConnection();
    }));
  }
}
export class PoolClient extends QueryClient {
  #release;
  constructor(config, releaseCallback){
    super(new Connection(config, async ()=>{
      await this.closeConnection();
    }));
    this.#release = releaseCallback;
  }
  release() {
    this.#release();
    // Cleanup all session related metadata
    this.resetSessionMetadata();
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvcG9zdGdyZXNAdjAuMTcuMC9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gXCIuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi50c1wiO1xuaW1wb3J0IHtcbiAgdHlwZSBDbGllbnRDb25maWd1cmF0aW9uLFxuICB0eXBlIENsaWVudE9wdGlvbnMsXG4gIHR5cGUgQ29ubmVjdGlvblN0cmluZyxcbiAgY3JlYXRlUGFyYW1zLFxufSBmcm9tIFwiLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fcGFyYW1zLnRzXCI7XG5pbXBvcnQge1xuICBRdWVyeSxcbiAgdHlwZSBRdWVyeUFyZ3VtZW50cyxcbiAgdHlwZSBRdWVyeUFycmF5UmVzdWx0LFxuICB0eXBlIFF1ZXJ5T2JqZWN0T3B0aW9ucyxcbiAgdHlwZSBRdWVyeU9iamVjdFJlc3VsdCxcbiAgdHlwZSBRdWVyeU9wdGlvbnMsXG4gIHR5cGUgUXVlcnlSZXN1bHQsXG4gIFJlc3VsdFR5cGUsXG4gIHRlbXBsYXRlU3RyaW5nVG9RdWVyeSxcbn0gZnJvbSBcIi4vcXVlcnkvcXVlcnkudHNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uLCB0eXBlIFRyYW5zYWN0aW9uT3B0aW9ucyB9IGZyb20gXCIuL3F1ZXJ5L3RyYW5zYWN0aW9uLnRzXCI7XG5pbXBvcnQgeyBpc1RlbXBsYXRlU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHMudHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGNvZGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBjdXJyZW50bHkgbG9ja2luZyB0aGUgY29ubmVjdGlvbi5cbiAgICogSWYgdGhlcmUgaXMgbm8gdHJhbnNhY3Rpb24gb25nb2luZywgdGhlIHRyYW5zYWN0aW9uIGNvZGUgd2lsbCBiZSBudWxsXG4gICAqL1xuICBjdXJyZW50X3RyYW5zYWN0aW9uOiBzdHJpbmcgfCBudWxsO1xuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcHJvY2VzcyBpZCBvZiB0aGUgY3VycmVudCBzZXNzaW9uIGFzIGFzc2lnbmVkIGJ5IHRoZSBkYXRhYmFzZVxuICAgKiBvbiBjb25uZWN0aW9uLiBUaGlzIGlkIHdpbGwgdW5kZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gY29ubmVjdGlvbiBzdGFibGlzaGVkXG4gICAqL1xuICBwaWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjYXJyaWVkIG92ZXIgVExTLiBJdCB3aWxsIGJlIHVuZGVmaW5lZCB3aGVuXG4gICAqIHRoZXJlIGlzIG5vIGNvbm5lY3Rpb24gc3RhYmxpc2hlZFxuICAgKi9cbiAgdGxzOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIHByb3RvY29sIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgZGF0YWJhc2VcbiAgICpcbiAgICogVGhlIHR3byBzdXBwb3J0ZWQgdHJhbnNwb3J0cyBhcmUgVENQIGFuZCBVbml4IHNvY2tldHNcbiAgICovXG4gIHRyYW5zcG9ydDogXCJ0Y3BcIiB8IFwic29ja2V0XCIgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBRdWVyeUNsaWVudCB7XG4gICNjb25uZWN0aW9uOiBDb25uZWN0aW9uO1xuICAjdGVybWluYXRlZCA9IGZhbHNlO1xuICAjdHJhbnNhY3Rpb246IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pIHtcbiAgICB0aGlzLiNjb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgfVxuXG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3Rpb24uY29ubmVjdGVkO1xuICB9XG5cbiAgZ2V0IHNlc3Npb24oKTogU2Vzc2lvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRfdHJhbnNhY3Rpb246IHRoaXMuI3RyYW5zYWN0aW9uLFxuICAgICAgcGlkOiB0aGlzLiNjb25uZWN0aW9uLnBpZCxcbiAgICAgIHRsczogdGhpcy4jY29ubmVjdGlvbi50bHMsXG4gICAgICB0cmFuc3BvcnQ6IHRoaXMuI2Nvbm5lY3Rpb24udHJhbnNwb3J0LFxuICAgIH07XG4gIH1cblxuICAjYXNzZXJ0T3BlbkNvbm5lY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuI3Rlcm1pbmF0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb25uZWN0aW9uIHRvIHRoZSBkYXRhYmFzZSBoYXMgYmVlbiB0ZXJtaW5hdGVkXCIsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBjbG9zZUNvbm5lY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLiNjb25uZWN0aW9uLmVuZCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRTZXNzaW9uTWV0YWRhdGEoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbnMgYXJlIGEgcG93ZXJmdWwgZmVhdHVyZSB0aGF0IGd1YXJhbnRlZXMgc2FmZSBvcGVyYXRpb25zIGJ5IGFsbG93aW5nIHlvdSB0byBjb250cm9sXG4gICAqIHRoZSBvdXRjb21lIG9mIGEgc2VyaWVzIG9mIHN0YXRlbWVudHMgYW5kIHVuZG8sIHJlc2V0LCBhbmQgc3RlcCBiYWNrIHNhaWQgb3BlcmF0aW9ucyB0b1xuICAgKiB5b3VyIGxpa2luZ1xuICAgKlxuICAgKiBJbiBvcmRlciB0byBjcmVhdGUgYSB0cmFuc2FjdGlvbiwgdXNlIHRoZSBgY3JlYXRlVHJhbnNhY3Rpb25gIG1ldGhvZCBpbiB5b3VyIGNsaWVudCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQudHNcIjtcbiAgICpcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgKiBjb25zdCB0cmFuc2FjdGlvbiA9IGNsaWVudC5jcmVhdGVUcmFuc2FjdGlvbihcIm15X3RyYW5zYWN0aW9uX25hbWVcIik7XG4gICAqXG4gICAqIGF3YWl0IHRyYW5zYWN0aW9uLmJlZ2luKCk7XG4gICAqIC8vIEFsbCBzdGF0ZW1lbnRzIGJldHdlZW4gYmVnaW4gYW5kIGNvbW1pdCB3aWxsIGhhcHBlbiBpbnNpZGUgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpOyAvLyBBbGwgY2hhbmdlcyBhcmUgc2F2ZWRcbiAgICogYGBgXG4gICAqXG4gICAqIEFsbCBzdGF0ZW1lbnRzIHRoYXQgZmFpbCBpbiBxdWVyeSBleGVjdXRpb24gd2lsbCBjYXVzZSB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiB0byBhYm9ydCBhbmQgcmVsZWFzZVxuICAgKiB0aGUgY2xpZW50IHdpdGhvdXQgYXBwbHlpbmcgYW55IG9mIHRoZSBjaGFuZ2VzIHRoYXQgdG9vayBwbGFjZSBpbnNpZGUgaXRcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LnRzXCI7XG4gICAqXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICogY29uc3QgdHJhbnNhY3Rpb24gPSBjbGllbnQuY3JlYXRlVHJhbnNhY3Rpb24oXCJ0cmFuc2FjdGlvblwiKTtcbiAgICpcbiAgICogYXdhaXQgdHJhbnNhY3Rpb24uYmVnaW4oKTtcbiAgICogYXdhaXQgdHJhbnNhY3Rpb24ucXVlcnlBcnJheWBJTlNFUlQgSU5UTyBNWV9UQUJMRSAoWCkgVkFMVUVTICR7XCJzb21lX3ZhbHVlXCJ9YDtcbiAgICogdHJ5IHtcbiAgICogICBhd2FpdCB0cmFuc2FjdGlvbi5xdWVyeUFycmF5YFNFTEVDVCBbXWA7IC8vIEludmFsaWQgc3ludGF4LCB0cmFuc2FjdGlvbiBhYm9ydGVkLCBjaGFuZ2VzIHdvbid0IGJlIGFwcGxpZWRcbiAgICogfWNhdGNoKGUpe1xuICAgKiAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpOyAvLyBXaWxsIHRocm93LCBjdXJyZW50IHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGZpbmlzaGVkXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoaXMgaG93ZXZlciwgb25seSBoYXBwZW5zIGlmIHRoZSBlcnJvciBpcyBvZiBleGVjdXRpb24gaW4gbmF0dXJlLCB2YWxpZGF0aW9uIGVycm9ycyB3b24ndCBhYm9ydFxuICAgKiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LnRzXCI7XG4gICAqXG4gICAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICogY29uc3QgdHJhbnNhY3Rpb24gPSBjbGllbnQuY3JlYXRlVHJhbnNhY3Rpb24oXCJ0cmFuc2FjdGlvblwiKTtcbiAgICpcbiAgICogYXdhaXQgdHJhbnNhY3Rpb24uYmVnaW4oKTtcbiAgICogYXdhaXQgdHJhbnNhY3Rpb24ucXVlcnlBcnJheWBJTlNFUlQgSU5UTyBNWV9UQUJMRSAoWCkgVkFMVUVTICR7XCJzb21lX3ZhbHVlXCJ9YDtcbiAgICogdHJ5IHtcbiAgICogICBhd2FpdCB0cmFuc2FjdGlvbi5yb2xsYmFjayhcInVuZXhpc3RlbnRfc2F2ZXBvaW50XCIpOyAvLyBWYWxpZGF0aW9uIGVycm9yXG4gICAqIH0gY2F0Y2goZSkge1xuICAgKiAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpOyAvLyBUcmFuc2FjdGlvbiB3aWxsIGVuZCwgY2hhbmdlcyB3aWxsIGJlIHNhdmVkXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEEgdHJhbnNhY3Rpb24gaGFzIG1hbnkgb3B0aW9ucyB0byBlbnN1cmUgbW9kaWZpY2F0aW9ucyBtYWRlIHRvIHRoZSBkYXRhYmFzZSBhcmUgc2FmZSBhbmRcbiAgICogaGF2ZSB0aGUgZXhwZWN0ZWQgb3V0Y29tZSwgd2hpY2ggaXMgYSBoYXJkIHRoaW5nIHRvIGFjY29tcGxpc2ggaW4gYSBkYXRhYmFzZSB3aXRoIG1hbnkgY29uY3VycmVudCB1c2VycyxcbiAgICogYW5kIGl0IGRvZXMgc28gYnkgYWxsb3dpbmcgeW91IHRvIHNldCBsb2NhbCBsZXZlbHMgb2YgaXNvbGF0aW9uIHRvIHRoZSB0cmFuc2FjdGlvbiB5b3UgYXJlIGFib3V0IHRvIGJlZ2luXG4gICAqXG4gICAqIEVhY2ggdHJhbnNhY3Rpb24gY2FuIGV4ZWN1dGUgd2l0aCB0aGUgZm9sbG93aW5nIGxldmVscyBvZiBpc29sYXRpb246XG4gICAqXG4gICAqIC0gUmVhZCBjb21taXR0ZWQ6IFRoaXMgaXMgdGhlIG5vcm1hbCBiZWhhdmlvciBvZiBhIHRyYW5zYWN0aW9uLiBFeHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBkYXRhYmFzZVxuICAgKiAgIHdpbGwgYmUgdmlzaWJsZSBpbnNpZGUgdGhlIHRyYW5zYWN0aW9uIG9uY2UgdGhleSBhcmUgY29tbWl0dGVkLlxuICAgKlxuICAgKiAtIFJlcGVhdGFibGUgcmVhZDogVGhpcyBpc29sYXRlcyB0aGUgdHJhbnNhY3Rpb24gaW4gYSB3YXkgdGhhdCBhbnkgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgZGF0YSB3ZSBhcmUgcmVhZGluZ1xuICAgKiAgIHdvbid0IGJlIHZpc2libGUgaW5zaWRlIHRoZSB0cmFuc2FjdGlvbiB1bnRpbCBpdCBoYXMgZmluaXNoZWRcbiAgICogICBgYGB0c1xuICAgKiAgIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICAgKlxuICAgKiAgIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICogICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IGNsaWVudC5jcmVhdGVUcmFuc2FjdGlvbihcIm15X3RyYW5zYWN0aW9uXCIsIHsgaXNvbGF0aW9uX2xldmVsOiBcInJlcGVhdGFibGVfcmVhZFwiIH0pO1xuICAgKiAgIGBgYFxuICAgKlxuICAgKiAtIFNlcmlhbGl6YWJsZTogVGhpcyBpc29sYXRpb24gbGV2ZWwgcHJldmVudHMgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gZnJvbSBtYWtpbmcgcGVyc2lzdGVudCBjaGFuZ2VzXG4gICAqICAgaWYgdGhlIGRhdGEgdGhleSB3ZXJlIHJlYWRpbmcgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbW9kaWZpZWQgKHJlY29tbWVuZGVkKVxuICAgKiAgIGBgYHRzXG4gICAqICAgaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LnRzXCI7XG4gICAqXG4gICAqICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgKiAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgY2xpZW50LmNyZWF0ZVRyYW5zYWN0aW9uKFwibXlfdHJhbnNhY3Rpb25cIiwgeyBpc29sYXRpb25fbGV2ZWw6IFwic2VyaWFsaXphYmxlXCIgfSk7XG4gICAqICAgYGBgXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgZWFjaCB0cmFuc2FjdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0d28gbGV2ZWxzIG9mIGFjY2VzcyB0byB0aGUgZGF0YTpcbiAgICpcbiAgICogLSBSZWFkIHdyaXRlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZGUsIGl0IGFsbG93cyB5b3UgdG8gZXhlY3V0ZSBhbGwgY29tbWFuZHMgeW91IGhhdmUgYWNjZXNzIHRvIG5vcm1hbGx5XG4gICAqXG4gICAqIC0gUmVhZCBvbmx5OiBEaXNhYmxlcyBhbGwgY29tbWFuZHMgdGhhdCBjYW4gbWFrZSBjaGFuZ2VzIHRvIHRoZSBkYXRhYmFzZS4gTWFpbiB1c2UgZm9yIHRoZSByZWFkIG9ubHkgbW9kZVxuICAgKiAgIGlzIHRvIGluIGNvbmp1Y3Rpb24gd2l0aCB0aGUgcmVwZWF0YWJsZSByZWFkIGlzb2xhdGlvbiwgZW5zdXJpbmcgdGhlIGRhdGEgeW91IGFyZSByZWFkaW5nIGRvZXMgbm90IGNoYW5nZVxuICAgKiAgIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24sIHNwZWNpYWxseSB1c2VmdWwgZm9yIGRhdGEgZXh0cmFjdGlvblxuICAgKiAgIGBgYHRzXG4gICAqICAgaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LnRzXCI7XG4gICAqXG4gICAqICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgKiAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgY2xpZW50LmNyZWF0ZVRyYW5zYWN0aW9uKFwibXlfdHJhbnNhY3Rpb25cIiwgeyByZWFkX29ubHk6IHRydWUgfSk7XG4gICAqICAgYGBgXG4gICAqXG4gICAqIExhc3QgYnV0IG5vdCBsZWFzdCwgdHJhbnNhY3Rpb25zIGFsbG93IHlvdSB0byBzaGFyZSBzdGFydGluZyBwb2ludCBzbmFwc2hvdHMgYmV0d2VlbiB0aGVtLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGluaXRpYWxpemVkIGEgcmVwZWF0YWJsZSByZWFkIHRyYW5zYWN0aW9uIGJlZm9yZSBhIHBhcnRpY3VsYXJseSBzZW5zaWJsZSBjaGFuZ2VcbiAgICogaW4gdGhlIGRhdGFiYXNlLCBhbmQgeW91IHdvdWxkIGxpa2UgdG8gc3RhcnQgc2V2ZXJhbCB0cmFuc2FjdGlvbnMgd2l0aCB0aGF0IHNhbWUgYmVmb3JlIHRoZSBjaGFuZ2Ugc3RhdGVcbiAgICogeW91IGNhbiBkbyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQudHNcIjtcbiAgICpcbiAgICogY29uc3QgY2xpZW50XzEgPSBuZXcgQ2xpZW50KCk7XG4gICAqIGNvbnN0IGNsaWVudF8yID0gbmV3IENsaWVudCgpO1xuICAgKiBjb25zdCB0cmFuc2FjdGlvbl8xID0gY2xpZW50XzEuY3JlYXRlVHJhbnNhY3Rpb24oXCJ0cmFuc2FjdGlvbl8xXCIpO1xuICAgKlxuICAgKiBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHRyYW5zYWN0aW9uXzEuZ2V0U25hcHNob3QoKTtcbiAgICogY29uc3QgdHJhbnNhY3Rpb25fMiA9IGNsaWVudF8yLmNyZWF0ZVRyYW5zYWN0aW9uKFwibmV3X3RyYW5zYWN0aW9uXCIsIHsgaXNvbGF0aW9uX2xldmVsOiBcInJlcGVhdGFibGVfcmVhZFwiLCBzbmFwc2hvdCB9KTtcbiAgICogLy8gdHJhbnNhY3Rpb25fMiBub3cgc2hhcmVzIHRoZSBzYW1lIHN0YXJ0aW5nIHN0YXRlIHRoYXQgdHJhbnNhY3Rpb25fMSBoYWRcbiAgICogYGBgXG4gICAqXG4gICAqIGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvMTQvdHV0b3JpYWwtdHJhbnNhY3Rpb25zLmh0bWxcbiAgICogaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy8xNC9zcWwtc2V0LXRyYW5zYWN0aW9uLmh0bWxcbiAgICovXG4gIGNyZWF0ZVRyYW5zYWN0aW9uKG5hbWU6IHN0cmluZywgb3B0aW9ucz86IFRyYW5zYWN0aW9uT3B0aW9ucyk6IFRyYW5zYWN0aW9uIHtcbiAgICB0aGlzLiNhc3NlcnRPcGVuQ29ubmVjdGlvbigpO1xuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihcbiAgICAgIG5hbWUsXG4gICAgICBvcHRpb25zLFxuICAgICAgdGhpcyxcbiAgICAgIC8vIEJpbmQgY29udGV4dCBzbyBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGlzXG4gICAgICB0aGlzLiNleGVjdXRlUXVlcnkuYmluZCh0aGlzKSxcbiAgICAgIChuYW1lOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9uID0gbmFtZTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVyeSBjbGllbnQgbXVzdCBpbml0aWFsaXplIHRoZWlyIGNvbm5lY3Rpb24gcHJldmlvdXNseSB0byB0aGVcbiAgICogZXhlY3V0aW9uIG9mIGFueSBzdGF0ZW1lbnRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy4jY29ubmVjdGlvbi5zdGFydHVwKGZhbHNlKTtcbiAgICAgIHRoaXMuI3Rlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2luZyB5b3VyIFBvc3RncmVTUUwgY29ubmVjdGlvbiB3aWxsIGRlbGV0ZSBhbGwgbm9uLXBlcnNpc3RlbnQgZGF0YVxuICAgKiB0aGF0IG1heSBoYXZlIGJlZW4gY3JlYXRlZCBpbiB0aGUgY291cnNlIG9mIHRoZSBzZXNzaW9uIGFuZCB3aWxsIHJlcXVpcmVcbiAgICogeW91IHRvIHJlY29ubmVjdCBpbiBvcmRlciB0byBleGVjdXRlIGZ1cnRoZXIgcXVlcmllc1xuICAgKi9cbiAgYXN5bmMgZW5kKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG5cbiAgICB0aGlzLiN0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jICNleGVjdXRlUXVlcnk8VCBleHRlbmRzIEFycmF5PHVua25vd24+PihcbiAgICBfcXVlcnk6IFF1ZXJ5PFJlc3VsdFR5cGUuQVJSQVk+LFxuICApOiBQcm9taXNlPFF1ZXJ5QXJyYXlSZXN1bHQ8VD4+O1xuICBhc3luYyAjZXhlY3V0ZVF1ZXJ5PFQ+KFxuICAgIF9xdWVyeTogUXVlcnk8UmVzdWx0VHlwZS5PQkpFQ1Q+LFxuICApOiBQcm9taXNlPFF1ZXJ5T2JqZWN0UmVzdWx0PFQ+PjtcbiAgYXN5bmMgI2V4ZWN1dGVRdWVyeShcbiAgICBxdWVyeTogUXVlcnk8UmVzdWx0VHlwZT4sXG4gICk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jY29ubmVjdGlvbi5xdWVyeShxdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGV4ZWN1dGVkIHF1ZXJpZXMgdG8gYmUgcmV0cmlldmVkIGFzIGFycmF5IGVudHJpZXMuXG4gICAqIEl0IHN1cHBvcnRzIGEgZ2VuZXJpYyBpbnRlcmZhY2UgaW4gb3JkZXIgdG8gdHlwZSB0aGUgZW50cmllcyByZXRyaWV2ZWQgYnkgdGhlIHF1ZXJ5XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICAgKlxuICAgKiBjb25zdCBteV9jbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAqXG4gICAqIGNvbnN0IHtyb3dzfSA9IGF3YWl0IG15X2NsaWVudC5xdWVyeUFycmF5KFxuICAgKiAgIFwiU0VMRUNUIElELCBOQU1FIEZST00gQ0xJRU5UU1wiXG4gICAqICk7IC8vIEFycmF5PHVua25vd25bXT5cbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gcGFzcyB0eXBlIGFyZ3VtZW50cyB0byB0aGUgcXVlcnkgaW4gb3JkZXIgdG8gaGludCBUeXBlU2NyaXB0IHdoYXQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICAgKlxuICAgKiBjb25zdCBteV9jbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAqIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgbXlfY2xpZW50LnF1ZXJ5QXJyYXk8W251bWJlciwgc3RyaW5nXT4oXG4gICAqICAgXCJTRUxFQ1QgSUQsIE5BTUUgRlJPTSBDTElFTlRTXCJcbiAgICogKTsgLy8gQXJyYXk8W251bWJlciwgc3RyaW5nXT5cbiAgICogYGBgXG4gICAqXG4gICAqIEl0IGFsc28gYWxsb3dzIHlvdSB0byBleGVjdXRlIHByZXBhcmVkIHN0YXRlbWVudHMgd2l0aCB0ZW1wbGF0ZSBzdHJpbmdzXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICAgKiBjb25zdCBteV9jbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAqXG4gICAqIGNvbnN0IGlkID0gMTI7XG4gICAqIC8vIEFycmF5PFtudW1iZXIsIHN0cmluZ10+XG4gICAqIGNvbnN0IHtyb3dzfSA9IGF3YWl0IG15X2NsaWVudC5xdWVyeUFycmF5PFtudW1iZXIsIHN0cmluZ10+YFNFTEVDVCBJRCwgTkFNRSBGUk9NIENMSUVOVFMgV0hFUkUgSUQgPSAke2lkfWA7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcXVlcnlBcnJheTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4+KFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgYXJncz86IFF1ZXJ5QXJndW1lbnRzLFxuICApOiBQcm9taXNlPFF1ZXJ5QXJyYXlSZXN1bHQ8VD4+O1xuICBhc3luYyBxdWVyeUFycmF5PFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPj4oXG4gICAgY29uZmlnOiBRdWVyeU9wdGlvbnMsXG4gICk6IFByb21pc2U8UXVlcnlBcnJheVJlc3VsdDxUPj47XG4gIGFzeW5jIHF1ZXJ5QXJyYXk8VCBleHRlbmRzIEFycmF5PHVua25vd24+PihcbiAgICBzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSxcbiAgICAuLi5hcmdzOiB1bmtub3duW11cbiAgKTogUHJvbWlzZTxRdWVyeUFycmF5UmVzdWx0PFQ+PjtcbiAgYXN5bmMgcXVlcnlBcnJheTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4gPSBBcnJheTx1bmtub3duPj4oXG4gICAgcXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSB8IHN0cmluZyB8IFF1ZXJ5T3B0aW9ucyxcbiAgICAuLi5hcmdzOiB1bmtub3duW10gfCBbUXVlcnlBcmd1bWVudHMgfCB1bmRlZmluZWRdXG4gICk6IFByb21pc2U8UXVlcnlBcnJheVJlc3VsdDxUPj4ge1xuICAgIHRoaXMuI2Fzc2VydE9wZW5Db25uZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy4jdHJhbnNhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoaXMgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgbG9ja2VkIGJ5IHRoZSBcIiR7dGhpcy4jdHJhbnNhY3Rpb259XCIgdHJhbnNhY3Rpb25gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnk6IFF1ZXJ5PFJlc3VsdFR5cGUuQVJSQVk+O1xuICAgIGlmICh0eXBlb2YgcXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBxdWVyeSA9IG5ldyBRdWVyeShcbiAgICAgICAgcXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnLFxuICAgICAgICBSZXN1bHRUeXBlLkFSUkFZLFxuICAgICAgICBhcmdzWzBdIGFzIFF1ZXJ5QXJndW1lbnRzIHwgdW5kZWZpbmVkLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVGVtcGxhdGVTdHJpbmcocXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnKSkge1xuICAgICAgcXVlcnkgPSB0ZW1wbGF0ZVN0cmluZ1RvUXVlcnkoXG4gICAgICAgIHF1ZXJ5X3RlbXBsYXRlX29yX2NvbmZpZyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgUmVzdWx0VHlwZS5BUlJBWSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHF1ZXJ5X3RlbXBsYXRlX29yX2NvbmZpZywgUmVzdWx0VHlwZS5BUlJBWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2V4ZWN1dGVRdWVyeShxdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGV4ZWN1dGVkIHF1ZXJpZXMgdG8gYmUgcmV0cmlldmVkIGFzIG9iamVjdCBlbnRyaWVzLlxuICAgKiBJdCBzdXBwb3J0cyBhIGdlbmVyaWMgaW50ZXJmYWNlIGluIG9yZGVyIHRvIHR5cGUgdGhlIGVudHJpZXMgcmV0cmlldmVkIGJ5IHRoZSBxdWVyeVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQudHNcIjtcbiAgICpcbiAgICogY29uc3QgbXlfY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgKlxuICAgKiB7XG4gICAqIFx0IGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgbXlfY2xpZW50LnF1ZXJ5T2JqZWN0KFxuICAgKiAgICAgXCJTRUxFQ1QgSUQsIE5BTUUgRlJPTSBDTElFTlRTXCJcbiAgICogXHQgKTsgLy8gUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICogfVxuICAgKlxuICAgKiB7XG4gICAqIFx0IGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgbXlfY2xpZW50LnF1ZXJ5T2JqZWN0PHtpZDogbnVtYmVyLCBuYW1lOiBzdHJpbmd9PihcbiAgICogICAgIFwiU0VMRUNUIElELCBOQU1FIEZST00gQ0xJRU5UU1wiXG4gICAqICAgKTsgLy8gQXJyYXk8e2lkOiBudW1iZXIsIG5hbWU6IHN0cmluZ30+XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBtYXAgdGhlIGV4cGVjdGVkIHJlc3VsdHMgdG8gb2JqZWN0IGZpZWxkcyB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBpbnRlcmZhY2UuXG4gICAqIFRoaXMgd2lsbCBiZSBhc3NpZ25lZCBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHByb3ZpZGVkXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICAgKlxuICAgKiBjb25zdCBteV9jbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAqXG4gICAqIHtcbiAgICogICBjb25zdCB7cm93c30gPSBhd2FpdCBteV9jbGllbnQucXVlcnlPYmplY3QoXG4gICAqICAgICBcIlNFTEVDVCBJRCwgTkFNRSBGUk9NIENMSUVOVFNcIlxuICAgKiAgICk7XG4gICAqXG4gICAqIFx0IGNvbnNvbGUubG9nKHJvd3MpOyAvLyBbe2lkOiA3OCwgbmFtZTogXCJGcmFua1wifSwge2lkOiAxNSwgbmFtZTogXCJTYXJhaFwifV1cbiAgICogfVxuICAgKlxuICAgKiB7XG4gICAqIFx0IGNvbnN0IHtyb3dzfSA9IGF3YWl0IG15X2NsaWVudC5xdWVyeU9iamVjdCh7XG4gICAqICAgICB0ZXh0OiBcIlNFTEVDVCBJRCwgTkFNRSBGUk9NIENMSUVOVFNcIixcbiAgICogIFx0IGZpZWxkczogW1wicGVyc29uYWxfaWRcIiwgXCJjb21wbGV0ZV9uYW1lXCJdLFxuICAgKiBcdCAgfSk7XG4gICAqXG4gICAqIFx0IGNvbnNvbGUubG9nKHJvd3MpOyAvLyBbe3BlcnNvbmFsX2lkOiA3OCwgY29tcGxldGVfbmFtZTogXCJGcmFua1wifSwge3BlcnNvbmFsX2lkOiAxNSwgY29tcGxldGVfbmFtZTogXCJTYXJhaFwifV1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIGV4ZWN1dGUgcHJlcGFyZWQgc3RhdGVtZW50cyB3aXRoIHRlbXBsYXRlIHN0cmluZ3NcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LnRzXCI7XG4gICAqXG4gICAqIGNvbnN0IG15X2NsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICogY29uc3QgaWQgPSAxMjtcbiAgICogLy8gQXJyYXk8e2lkOiBudW1iZXIsIG5hbWU6IHN0cmluZ30+XG4gICAqIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgbXlfY2xpZW50LnF1ZXJ5T2JqZWN0PHtpZDogbnVtYmVyLCBuYW1lOiBzdHJpbmd9PmBTRUxFQ1QgSUQsIE5BTUUgRlJPTSBDTElFTlRTIFdIRVJFIElEID0gJHtpZH1gO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHF1ZXJ5T2JqZWN0PFQ+KFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgYXJncz86IFF1ZXJ5QXJndW1lbnRzLFxuICApOiBQcm9taXNlPFF1ZXJ5T2JqZWN0UmVzdWx0PFQ+PjtcbiAgYXN5bmMgcXVlcnlPYmplY3Q8VD4oXG4gICAgY29uZmlnOiBRdWVyeU9iamVjdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UXVlcnlPYmplY3RSZXN1bHQ8VD4+O1xuICBhc3luYyBxdWVyeU9iamVjdDxUPihcbiAgICBxdWVyeTogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gICAgLi4uYXJnczogdW5rbm93bltdXG4gICk6IFByb21pc2U8UXVlcnlPYmplY3RSZXN1bHQ8VD4+O1xuICBhc3luYyBxdWVyeU9iamVjdDxcbiAgICBUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gID4oXG4gICAgcXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnOlxuICAgICAgfCBzdHJpbmdcbiAgICAgIHwgUXVlcnlPYmplY3RPcHRpb25zXG4gICAgICB8IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICAgIC4uLmFyZ3M6IHVua25vd25bXSB8IFtRdWVyeUFyZ3VtZW50cyB8IHVuZGVmaW5lZF1cbiAgKTogUHJvbWlzZTxRdWVyeU9iamVjdFJlc3VsdDxUPj4ge1xuICAgIHRoaXMuI2Fzc2VydE9wZW5Db25uZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy4jdHJhbnNhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoaXMgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgbG9ja2VkIGJ5IHRoZSBcIiR7dGhpcy4jdHJhbnNhY3Rpb259XCIgdHJhbnNhY3Rpb25gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnk6IFF1ZXJ5PFJlc3VsdFR5cGUuT0JKRUNUPjtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5X3RlbXBsYXRlX29yX2NvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoXG4gICAgICAgIHF1ZXJ5X3RlbXBsYXRlX29yX2NvbmZpZyxcbiAgICAgICAgUmVzdWx0VHlwZS5PQkpFQ1QsXG4gICAgICAgIGFyZ3NbMF0gYXMgUXVlcnlBcmd1bWVudHMgfCB1bmRlZmluZWQsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNUZW1wbGF0ZVN0cmluZyhxdWVyeV90ZW1wbGF0ZV9vcl9jb25maWcpKSB7XG4gICAgICBxdWVyeSA9IHRlbXBsYXRlU3RyaW5nVG9RdWVyeShcbiAgICAgICAgcXVlcnlfdGVtcGxhdGVfb3JfY29uZmlnLFxuICAgICAgICBhcmdzLFxuICAgICAgICBSZXN1bHRUeXBlLk9CSkVDVCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KFxuICAgICAgICBxdWVyeV90ZW1wbGF0ZV9vcl9jb25maWcgYXMgUXVlcnlPYmplY3RPcHRpb25zLFxuICAgICAgICBSZXN1bHRUeXBlLk9CSkVDVCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2V4ZWN1dGVRdWVyeTxUPihxdWVyeSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRTZXNzaW9uTWV0YWRhdGEoKSB7XG4gICAgdGhpcy4jdHJhbnNhY3Rpb24gPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ2xpZW50cyBhbGxvdyB5b3UgdG8gY29tbXVuaWNhdGUgd2l0aCB5b3VyIFBvc3RncmVTUUwgZGF0YWJhc2UgYW5kIGV4ZWN1dGUgU1FMXG4gKiBzdGF0ZW1lbnRzIGFzeW5jaHJvbm91c2x5XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICpcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAqIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG4gKiBhd2FpdCBjbGllbnQucXVlcnlBcnJheWBVUERBVEUgTVlfVEFCTEUgU0VUIE1ZX0ZJRUxEID0gMGA7XG4gKiBhd2FpdCBjbGllbnQuZW5kKCk7XG4gKiBgYGBcbiAqXG4gKiBBIGNsaWVudCB3aWxsIGV4ZWN1dGUgYWxsIHRoZWlyIHF1ZXJpZXMgaW4gYSBzZXF1ZW50aWFsIGZhc2hpb24sXG4gKiBmb3IgY29uY3VycmVuY3kgY2FwYWJpbGl0aWVzIGNoZWNrIG91dCBjb25uZWN0aW9uIHBvb2xzXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC50c1wiO1xuICpcbiAqIGNvbnN0IGNsaWVudF8xID0gbmV3IENsaWVudCgpO1xuICogYXdhaXQgY2xpZW50XzEuY29ubmVjdCgpO1xuICogLy8gRXZlbiBpZiBvcGVyYXRpb25zIGFyZSBub3QgYXdhaXRlZCwgdGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmVcbiAqIC8vIHNjaGVkdWxlZFxuICogY2xpZW50XzEucXVlcnlBcnJheWBVUERBVEUgTVlfVEFCTEUgU0VUIE1ZX0ZJRUxEID0gMGA7XG4gKiBjbGllbnRfMS5xdWVyeUFycmF5YERFTEVURSBGUk9NIE1ZX1RBQkxFYDtcbiAqXG4gKiBjb25zdCBjbGllbnRfMiA9IG5ldyBDbGllbnQoKTtcbiAqIGF3YWl0IGNsaWVudF8yLmNvbm5lY3QoKTtcbiAqIC8vIGBjbGllbnRfMmAgd2lsbCBleGVjdXRlIGl0J3MgcXVlcmllcyBpbiBwYXJhbGxlbCB0byBgY2xpZW50XzFgXG4gKiBjb25zdCB7cm93czogcmVzdWx0fSA9IGF3YWl0IGNsaWVudF8yLnF1ZXJ5QXJyYXlgU0VMRUNUICogRlJPTSBNWV9UQUJMRWA7XG4gKlxuICogYXdhaXQgY2xpZW50XzEuZW5kKCk7XG4gKiBhd2FpdCBjbGllbnRfMi5lbmQoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ2xpZW50IGV4dGVuZHMgUXVlcnlDbGllbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBDbGllbnRPcHRpb25zIHwgQ29ubmVjdGlvblN0cmluZykge1xuICAgIHN1cGVyKFxuICAgICAgbmV3IENvbm5lY3Rpb24oY3JlYXRlUGFyYW1zKGNvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvb2xDbGllbnQgZXh0ZW5kcyBRdWVyeUNsaWVudCB7XG4gICNyZWxlYXNlOiAoKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogQ2xpZW50Q29uZmlndXJhdGlvbiwgcmVsZWFzZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoXG4gICAgICBuZXcgQ29ubmVjdGlvbihjb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy4jcmVsZWFzZSA9IHJlbGVhc2VDYWxsYmFjaztcbiAgfVxuXG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy4jcmVsZWFzZSgpO1xuXG4gICAgLy8gQ2xlYW51cCBhbGwgc2Vzc2lvbiByZWxhdGVkIG1ldGFkYXRhXG4gICAgdGhpcy5yZXNldFNlc3Npb25NZXRhZGF0YSgpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxVQUFVLFFBQVEsNkJBQTZCO0FBQ3hELFNBSUUsWUFBWSxRQUNQLG9DQUFvQztBQUMzQyxTQUNFLEtBQUssRUFPTCxVQUFVLEVBQ1YscUJBQXFCLFFBQ2hCLG1CQUFtQjtBQUMxQixTQUFTLFdBQVcsUUFBaUMseUJBQXlCO0FBQzlFLFNBQVMsZ0JBQWdCLFFBQVEsbUJBQW1CO0FBMEJwRCxPQUFPLE1BQWU7RUFDcEIsQ0FBQyxVQUFVLENBQWE7RUFDeEIsQ0FBQyxVQUFVLEdBQUcsTUFBTTtFQUNwQixDQUFDLFdBQVcsR0FBa0IsS0FBSztFQUVuQyxZQUFZLFVBQXNCLENBQUU7SUFDbEMsSUFBSSxDQUFDLENBQUMsVUFBVSxHQUFHO0VBQ3JCO0VBRUEsSUFBSSxZQUFZO0lBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUztFQUNuQztFQUVBLElBQUksVUFBbUI7SUFD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